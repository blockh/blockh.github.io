{"pages":[{"title":"","text":"","link":"/album/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：平平的马路 网站地址：https://blockh.github.io 网站简介：Coding the world 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事Android移动开发 博客信息 网站主题为amazing，其原主题为Icarus主题 追求尽可能的简洁，清晰，易用。 更新日志：–2021.06.25：创建博客","link":"/about/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: 'e1499f734d835660ddff', clientSecret: 'b655baa951b1817cb47f173e1b337b1f47cb57d2', id: 'Pinguoooo', repo: 'blog_comment', owner: 'blockh', admin: \"blockh\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"}],"posts":[{"title":"Android-虚拟导航键显示隐藏监听及自动设定高度","text":"虚拟导航键显示隐藏监听及自动设定高度问题描述某些型号在某些布局下使用虚拟导航栏不能自动调整布局，导致遮挡。特别是华为手机。。。 问题解决步骤 获取根布局 设置 ViewTree 的全局界面监听 当捕获到界面更新时，去判断虚拟导航键是否弹出或隐藏然后做出相应的操作 实现1. 获取根布局123456789101112131415161718192021public class MainActivity implements ViewTreeObserver.OnGlobalLayoutListener{//虚拟导航栏自适应FrameLayout content;private boolean mLayoutComplete = false; ...@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); content = (FrameLayout) findViewById(android.R.id.content);}//捕获界面监听@Overridepublic void onGlobalLayout() { ...} ...} 2. 设置监听12345678910111213@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); content = (FrameLayout) findViewById(android.R.id.content); content.post(new Runnable() { @Override public void run() { mLayoutComplete = true; LogUtils.d(&quot;content 布局完成&quot;); } }); content.getViewTreeObserver().addOnGlobalLayoutListener(this);} 3. 捕获监听事件并做出虚拟导航是否隐藏的相应操作捕获监听123456@Overridepublic void onGlobalLayout() { LogUtils.d(&quot;onGlobalLayout&quot;); if (!mLayoutComplete) return; onNavigationBarStatusChanged();} 虚拟导航是否隐藏的相应操作在这里我判断虚拟导航键是否弹出的依据是 当前屏幕真实高度 是否大于 屏幕高度 。 123456789protected void onNavigationBarStatusChanged() { //这里的操作是为虚拟导航键留出相应高度，以适应某些型号在使用虚拟导航栏不能自动调整布局，导致遮挡。 if (ScreenUtils.getRealHeight() &gt; ScreenUtils.getHeight()) { getWindow().getDecorView().findViewById(android.R.id.content).setPadding(0, 0, 0,ScreenUtils.getNavigationBarHeight(this)); getWindow().setNavigationBarColor(Color.parseColor(&quot;#000000&quot;)); } else { getWindow().getDecorView().findViewById(android.R.id.content).setPadding(0, 0, 0, 0); }} 4.其他方法12345678910111213141516171819202122232425262728293031323334353637383940414243public class ScreenUtils { /** * 非全面屏下 虚拟键高度(无论是否隐藏) * @param context * @return */ public static int getNavigationBarHeight(Context context){ int result = 0; int resourceId = context.getResources().getIdentifier(&quot;navigation_bar_height&quot;,&quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) { result = context.getResources().getDimensionPixelSize(resourceId); } return result; } /** * 获取手机屏幕高度 */ public static int getHeight() { DisplayMetrics dm = new DisplayMetrics(); WindowManager windowManager = (WindowManager) BaseApplication.getInstance().getSystemService(Context.WINDOW_SERVICE); windowManager.getDefaultDisplay().getMetrics(dm); return dm.heightPixels; } /** * 获取屏幕真实高度（包括虚拟键盘） * */ public static int getRealHeight() { WindowManager windowManager = (WindowManager) BaseApplication.getInstance().getSystemService(Context.WINDOW_SERVICE); Display display = windowManager.getDefaultDisplay(); DisplayMetrics dm = new DisplayMetrics(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) { display.getRealMetrics(dm); } else { display.getMetrics(dm); } int realHeight = dm.heightPixels; return realHeight; } } 总结以下为封装代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * @ClassName: ScreenUtils * @Description: * @Author: pinguoooo * @Date: 2020/9/1 13:48 */public class ScreenUtils { /** * 非全面屏下 虚拟键高度(无论是否隐藏) * * @param context * @return */ public static int getNavigationBarHeight(Context context) { int result = 0; int resourceId = context.getResources().getIdentifier(&quot;navigation_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) { result = context.getResources().getDimensionPixelSize(resourceId); } return result; } /** * 获取手机屏幕高度 */ public static int getHeight() { DisplayMetrics dm = new DisplayMetrics(); WindowManager windowManager = (WindowManager) BaseApplication.getInstance().getSystemService(Context.WINDOW_SERVICE); windowManager.getDefaultDisplay().getMetrics(dm); return dm.heightPixels; } /** * 获取屏幕真实高度（包括虚拟键盘） */ public static int getRealHeight() { WindowManager windowManager = (WindowManager) BaseApplication.getInstance().getSystemService(Context.WINDOW_SERVICE); Display display = windowManager.getDefaultDisplay(); DisplayMetrics dm = new DisplayMetrics(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) { display.getRealMetrics(dm); } else { display.getMetrics(dm); } int realHeight = dm.heightPixels; return realHeight; } public interface NavigationListener { void show(); void hide(); } //虚拟导航栏显示/隐藏 public static void setNavigationListener(final View rootView, final NavigationListener navigationListener) { if (rootView == null || navigationListener == null) { return; } rootView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { if (ScreenUtils.getRealHeight() &gt; ScreenUtils.getHeight()) { //显示虚拟按键 if (navigationListener != null) { navigationListener.show(); } } else { //隐藏虚拟按键 if (navigationListener != null) { navigationListener.hide(); } } } }); }} 注： 在使用 setNavigationListener 时，传入的 rootView 为对应的 android.R.id.content 布局（FrameLayout 类型），传入别的可能没有效果。在这里我判断虚拟导航键是否弹出的依据是 当前屏幕真实高度 是否大于 屏幕高度 。 之后在使用时只需要对出现虚拟导航栏出现覆盖问题的 Activity 添加对 rootView 的监听，即可方便的实现虚拟导航栏隐藏与显示的监听。 12345678910111213141516@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); content = (FrameLayout) findViewById(android.R.id.content); ScreenUtils.setNavigationListener(content, new ScreenUtils.NavigationListener() { @Override public void show() { // 虚拟导航栏显示的操作 } @Override public void hide() { // 虚拟导航栏隐藏的操作 } });}","link":"/2021/06/25/Android-%E8%99%9A%E6%8B%9F%E5%AF%BC%E8%88%AA%E9%94%AE%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E7%9B%91%E5%90%AC%E5%8F%8A%E8%87%AA%E5%8A%A8%E8%AE%BE%E5%AE%9A%E9%AB%98%E5%BA%A6/"},{"title":"my-first","text":"","link":"/2021/06/25/my-first/"}],"tags":[],"categories":[]}